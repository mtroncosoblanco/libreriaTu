{"version":3,"sources":["../../../src/services/auth.service.ts"],"sourcesContent":["import { prisma } from \"../database/database\";\r\nimport { HttpException } from \"../exceptions/httpException\";\r\nimport { User } from \"@prisma/client\";\r\nimport bcrypt from \"bcrypt\"\r\nimport jwt from \"jsonwebtoken\"\r\n\r\n// usar un patron: singlenton\r\n//const prisma = new PrismaClient()\r\nconst TOKEN_PASSWORD = process.env.TOKEN_PASSWORD || 'pass'\r\n\r\nexport class AuthService {\r\n    static async register(user: User) {\r\n        // ver si el usuario no existe\r\n        // SELECT id,nombre FROM user WHERE email=user.email\r\n        const findUser = await prisma.user.findUnique({where: {email: user.email}})\r\n        if (findUser) throw new HttpException(409, `User ${user.email} already exists`)\r\n\r\n        // encriptar el password\r\n        const passwordEncrypted = await bcrypt.hash(user.password, 10)\r\n        user.password=''\r\n        // guardar el usuario en la bd\r\n        // INSERT INTO user (name, password, email) VALUES (?,?,?)\r\n        return await prisma.user.create({\r\n            data:{\r\n                ...user,\r\n                password: passwordEncrypted,\r\n                role: null,\r\n                //a:'aa'\r\n            },\r\n            omit:{\r\n                password:true\r\n            }\r\n        })\r\n    }\r\n\r\n    static async login(email:string, password:string){\r\n         // ver si el usuario existe\r\n        //const query = `SELECT id, email, role, password FROM user WHERE email='${email}'`\r\n        //const findUsers = await prisma.$queryRawUnsafe(query) as User[]\r\n        //const findUser = findUsers[0]\r\n\r\n        const findUser = await prisma.user.findUnique({where:{email}})\r\n        if(!findUser) throw new HttpException(401, 'Invalid user or password')\r\n         // ver si el password coincide\r\n        const isPasswordCorrect = await bcrypt.compare(password, findUser.password)\r\n        if(!isPasswordCorrect) throw new HttpException(401,'Invalid user or password')\r\n\r\n        // generar el token de autenticaci√≥n\r\n        const token = jwt.sign(\r\n            {colorFavorito:'azul', id:findUser.id, email:findUser.email, role:findUser.role}, \r\n            TOKEN_PASSWORD, \r\n            {expiresIn:\"1h\"}\r\n        )\r\n        // devolver el token y el usuario\r\n        return {token, user: { id: findUser.id, email: findUser.email, role: findUser.role } }\r\n    }\r\n\r\n}"],"names":["AuthService","TOKEN_PASSWORD","process","env","register","user","findUser","prisma","findUnique","where","email","HttpException","passwordEncrypted","bcrypt","hash","password","create","data","role","omit","login","isPasswordCorrect","compare","token","jwt","sign","colorFavorito","id","expiresIn"],"mappings":";;;;+BAUaA;;;eAAAA;;;0BAVU;+BACO;+DAEX;qEACH;;;;;;AAIhB,MAAMC,iBAAiBC,QAAQC,GAAG,CAACF,cAAc,IAAI;AAE9C,IAAA,AAAMD,cAAN,MAAMA;IACT,aAAaI,SAASC,IAAU,EAAE;QAG9B,MAAMC,WAAW,MAAMC,gBAAM,CAACF,IAAI,CAACG,UAAU,CAAC;YAACC,OAAO;gBAACC,OAAOL,KAAKK,KAAK;YAAA;QAAC;QACzE,IAAIJ,UAAU,MAAM,IAAIK,4BAAa,CAAC,KAAK,CAAC,KAAK,EAAEN,KAAKK,KAAK,CAAC,eAAe,CAAC;QAG9E,MAAME,oBAAoB,MAAMC,eAAM,CAACC,IAAI,CAACT,KAAKU,QAAQ,EAAE;QAC3DV,KAAKU,QAAQ,GAAC;QAGd,OAAO,MAAMR,gBAAM,CAACF,IAAI,CAACW,MAAM,CAAC;YAC5BC,MAAK;gBACD,GAAGZ,IAAI;gBACPU,UAAUH;gBACVM,MAAM;YAEV;YACAC,MAAK;gBACDJ,UAAS;YACb;QACJ;IACJ;IAEA,aAAaK,MAAMV,KAAY,EAAEK,QAAe,EAAC;QAM7C,MAAMT,WAAW,MAAMC,gBAAM,CAACF,IAAI,CAACG,UAAU,CAAC;YAACC,OAAM;gBAACC;YAAK;QAAC;QAC5D,IAAG,CAACJ,UAAU,MAAM,IAAIK,4BAAa,CAAC,KAAK;QAE3C,MAAMU,oBAAoB,MAAMR,eAAM,CAACS,OAAO,CAACP,UAAUT,SAASS,QAAQ;QAC1E,IAAG,CAACM,mBAAmB,MAAM,IAAIV,4BAAa,CAAC,KAAI;QAGnD,MAAMY,QAAQC,qBAAG,CAACC,IAAI,CAClB;YAACC,eAAc;YAAQC,IAAGrB,SAASqB,EAAE;YAAEjB,OAAMJ,SAASI,KAAK;YAAEQ,MAAKZ,SAASY,IAAI;QAAA,GAC/EjB,gBACA;YAAC2B,WAAU;QAAI;QAGnB,OAAO;YAACL;YAAOlB,MAAM;gBAAEsB,IAAIrB,SAASqB,EAAE;gBAAEjB,OAAOJ,SAASI,KAAK;gBAAEQ,MAAMZ,SAASY,IAAI;YAAC;QAAE;IACzF;AAEJ"}